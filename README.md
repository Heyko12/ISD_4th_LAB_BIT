При устройстве в Сбертех мной был пройден подготовительный курс организации, знакомящий с основами DevOps архитектуры в компании. Там я настроила сборку и автоматическое тестирование посредством плагина jacoco простейшего бэкенд-приложения, написанного на Java, проверку покрытия его тестами в SonarQube, настроила Quality Gate-ы этой проверки, после чего собранный дистрибутив моего приложения грузился в хранилище дистрибутивов Nexus и проходил проверки на уязвимости SAST и OSS, а в конце пайплайна вызывалась труба по раскатке дистрибутива моего приложения на тренировочные стенды организации. По согласованию с лектором курса в этом документе я изложу суть этого задания подробнее и приложу удостоверяющие скриншоты из репозитория и трубы в качестве выполнения четвертого ДЗ курса.

Для начала обсудим вкраце само приложение. Оно состоит из двух коротких модулей – ручки на healthcheck и main-а: 

![image1](images/image1.jpg)

![image2](images/image2.jpg)

Для этих файлов в репозитории лежат соответствующие тесты:

![image3](images/image3.jpg)

![image4](images/image4.jpg)

Чтобы приложение собиралось maven-ом, необходимо, во-первых, положить в корень проекта его конфигурационный файл pom.xml (привожу тут только его часть, здесь подключается spring, junit и jacoco):

![image5](images/image5.jpg)

Во-вторых, необходимо в корень проекта положить файл settings.xml, в котором описано по каким зеркалам и с какими кредами надо проходить во внутренние репозитории библиотек организации чтобы подтягивать зависимости:

![image6](images/image6.jpg)

Далее, в самом Jenkinsfile необходимо описать соответствующий стейдж:

![image7](images/image7.jpg)

Наконец, чтобы Jenkins знал с каким репозиторием работает, необходимо дать права на чтение технической учетной записи Jenkins в настройках самого репозитория, а также корректно настроить Branch Sources в Item-е Jenkins-а при его создании. Для того, чтобы сделать прохождение пайплайна обязательным этапом релиза, необходимо также настроить webhook из Bitbucket-а в Jenkins с установкой параметра Minimum successful build = 1:

![image8](images/image8.jpg)

![image9](images/image9.jpg)

Наконец, все настроено, и мы можем видеть в логах трубы, стриггеревшейся на очередной коммит, соответствующее сообщение:

![image10](images/image10.jpg)

Следующее, чего мы хотим добиться – это сканирование нашего кода инструментом SonarQube, для этого нужно создать свой проект во внутреннем сервисе банка и корректно его настроить, что приводить здесь я не буду, после чего надо выпустить себе токен и добавить его к кредам дженкинса:

![image11](images/image11.jpg)

После чего достаточно просто поменять Jenkinsfile, и результаты тестирования кода станут видны в созданном нами проекте:

![image12](images/image12.jpg)

![image13](images/image13.jpg)

Покрытие тестами относительно низкое, но это только потому, что тестировать там по существу нечего – проект слишком мал. Чтобы сделать достижение дефолтных пороговых показателей необходимым условием для релиза, необходимо также добавить в Jenkinsfile соответствующий стейдж:

![image14](images/image14.jpg)

Тогда в логах мы увидим соответствующее сообщение о прохождении QG:

![image15](images/image15.jpg)

Теперь добьемся загрузки дистрибутива нашего приложения в Nexus, для этого необходимо было ранее установить правильно зеркало для соответствующего плагина maven, а также добавить в Jenkinsfile стейдж загрузки в Nexus и стейдж определения версии приложения из номера билда, чтобы при каждой новой сборке, требующей загрузки дистрибутива в нексус (а как описано в стейдже Upload Nexus 3, таковыми являются только сборки из release и hotfix веток), формировалось новое url загрузки:

![image16](images/image16.jpg)

![image17](images/image17.jpg)

Теперь в логах трубы можно увидеть сообщение об успешной загрузке дистрибутива в Nexus, а также ссылку на загруженный дистрибутив:

![image18](images/image18.jpg)

Из проверок, которые требовалось произвести для выпускаемого дистрибутива в этом задании, остаются только проверки SAST и OSS. Первая занимается базовыми проверками на уязвимости статическим анализом кода, а вторая проверяет насколько безопасны наши зависимости. Данные проверки грузят результаты прохождения в отдельный сервис - quality gates manager - в качестве логических флагов, которые подбираются еще одним стейджом - Generate Release Notes, который собирает информацию о дистрибутиве выпускаемого приложения, биндит к ней заведенные задачи в Jira (основываясь на комментариях к коммиту), собирает флаги из сервиса quality gates manager, прикладывает к полученному дистрибутив из nexus и вновь загружает все в quality gates manager. Чтобы заставить работать все вышеперечисленное, надо сложить конфиг-файл для джобов проверки SAST и OSS в корень проекта – файл devseops-config.yml:

![image19](images/image19.jpg)

И поменять сам Jenkinsfile, добавив в него следующее (функция setFlag и стейджы SAST, OSS проверок и формирования Release Notes):

![image20](images/image20.jpg)

![image21](images/image21.jpg)

![image22](images/image22.jpg)
 
В логах трубы это выльется в соответствующие сообщения об успешном прохождении проверок и формировании release notes:

![image23](images/image23.jpg)

![image24](images/image24.jpg)

Наконец, остается только настроить CD процесс, но банке это устроено совсем просто, конечно только если целевая труба деплоймента настроена правильно, в данном случае это требует от нас добавить в Jenkinsfile соответствующий стейдж:

![image25](images/image25.jpg)

Данная джоба буквально представляет из себя отыгрыш определенных ансибловских плейбуков:

![image26](images/image26.jpg)

Вот как в итоге выглядит весь наш пайплайн целиком:

![image27](images/image27.jpg)
